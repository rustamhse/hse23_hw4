# Домашнее задание №3 (`HW #3 (MV)`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Требования к промежуточной попытке](#требования-к-промежуточной-попытке)
    1. [Правила игры](#правила-игры)
    1. [Консольное приложение](#консольное-приложение)
    1. [Структура программы](#структура-программы)
    1. [Фреймворк для тестов](#фреймворк-для-тестов)
    1. [Структура тестов](#структура-тестов)
    1. [Структура репозитория](#структура-репозитория)
1. [Бонусное задание](#бонусное-задание)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание
Реализуйте консольное приложение-игру `./hw-03_mv` крестики-нолики 10 на 10 (5 в ряд) для двух игроков.
Требуется два режима работы: по умолчанию перед каждым ходом на экран выводится поле,
в _молчаливом_ режиме поле выводится только один раз в конце игры.

В архитектуре должны быть явно выделены кдассы "модель" и "отображение" (model-view);
первый отвечает за логику игры, второй — за взаимодействие с пользователем
и конкретный формат ввода-вывода.

Если реализовано несколько отображений, общая логика взаимодействия
с пользователем должна быть выделена в "контроллер", чтобы получился
стандартный MVC (model-view-controller).

Также должен быть реализован собственный фреймворк для юнит-тестирования
и написаны автотесты для "модели".

## Требования к корректности решения
### Базовые требования
В этом задании действуют и дополнительные требования:

* Тесты модели должны собираться в программу `./test_hw-03_mv`.
* Каждый публичный метод модели (класса `Board`) должен быть протестирован
  как минимум тремя тестовыми методами класса `BoardTest` (три теста на один метод/функцию).
* Команды `make`, `make all` должны, помимо `./hw-03_mv`, собирать `./test_hw-03_mv`.
* Приложение `./test_hw-03_mv` должно завершаться с нулевым кодом возврата
  если и только если все автоматические тесты полностью пройдены.
* Приложение `./hw-03_mv` не должно запускать тесты.

### Правила игры
Игра ведется на игровом поле — квадрат 10 на 10 клеток.
Один игрок играет крестиками, второй — ноликами.

Первыми начинают _нолики_.
Игроки ходят по очереди.
В свой ход игрок может поставить на свободную клетку свой знак.

Целью игры является выставить 5 своих знаков в ряд по вертикали, горизонтали или любой из двух диагоналей.
Выигрывает тот игрок, который сделает это первым.
Если свободных клеток на игровом поле не осталось, то назначается ничья.

### Консольное приложение
Приложение запускается как `./hw-03_mv` (режим по умолчанию) или `./hw-03_mv silent` (_молчаливый_ режим)
и сразу начинает единственную игру с управлением через консоль.

Исходно поле пустое.
В начале каждого хода выводится игровое поле и приглашение: <code>X move:&nbsp;</code> — для крестиков и <code>O move:&nbsp;</code> — для ноликов (нолики обозначаются латинской буквой «O»).
Обратите внимание на пробел после двоеточия.
В ответ на приглашение пользователь должен ввести параметры хода — два числа (строка и столбец, числа от 0 до 9) через пробел, после чего перевод строки.
Если введен некорректный ход (например, некорректный формат чисел, клетка занята и т.д.), то выводится сообщение `Bad move!`, затем ход запрашивается повторно (приглашение выводится еще раз, доску выводить не нужно).
Также пользователь в ответ на приглашение может ввести два числа -1 и -1, в этом случае
программа должно немедленно корректно завершиться без дополнительных сообщений.

Если пользователь добавляет лишние ведущие нули и/или пробельные символы до/после/между числами,
это всё ещё считается корректным ходом.
Гарантируется, что в ответ на приглашение пользователь вводит строчку из произвольных символов с ASCII-кодами от 32 до 127,
завершённую ровно одним символом перевода строки.

Если после хода партия закончилась, то на экран выводится (в отдельной строчке после игрового поля) один из результатов игры: `X wins!`, `O wins!` или `Draw.`,
после чего программа корректно завершается.

По умолчанию в начале каждого хода на экран выводится игровое поле.
В _молчаливом_ режиме игровое поле выводится только один раз после окончания игры (перед надписью с результатом игры).
Доска должна вводится в виде строк из символов, описывающих клетки (`X` — буква «X», крестик; `O` — буква «O», нолик; `.` — точка, незанятая клетка), например:
```
XXXX.....O
XOXOXOXOXO
X........O
O........X
OXOXOXOXOX
XXXX.....O
XOXOXOXOXO
X........O
O........X
OXOXOXOXOX
```

Пример партии. Обратите внимание на переводы строк и пробелы.

|Ввод|Вывод|
|:---|:----|
| |`​` _(здесь и далее: пустая строчка)_<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code> _(здесь и далее без перевода строки)_|
|`1 1`|`​`<br/>`..........`<br/>`.O........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>X move:&nbsp;</code>|
|`0 0`|`​`<br/>`X.........`<br/>`.O........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code>|
|`0 0`|`Bad move!`<br/><code>O move:&nbsp;</code>
|`1 0`|`​`<br/>`X.........`<br/>`OO........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code>| 
|`0 1`| _ходы опущены_
|_ходы опущены_|`​`<br/>`XXXX......`<br/>`OOOO......`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code>|
|`1 4`|`​`<br/>`XXXX......`<br/>`OOOOO.....`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`O wins!` _(с переводом строки)_|

Доступна [запись работы в терминале](https://asciinema.org/a/xUrsyAeHAXQUBiDXlK1eC0qNE) для этого примера.
Также эту запись можно просмотреть с помощью команды `asciinema play cli-demo.asciinema`.
На записи также есть демонстрация _молчаливого_ режима.

### Структура программы
* Модель представлена классом `Board`, описывает логику игры и её внутреннее представление.
  Реализована в файлах `Board.h` и `Board.cpp`.
  * Модель должно быть можно без изменений использовать в схожих программах для
    игры в крестики-нолики.
  * Разрешается использовать вспомогательные классы.
* Основное отображение представлено классом `StdioBoardView` и описывает текстовый интерфейс
  и логику взаимодействия с пользователем.
  Реализовано в `StdioBoardView.h` и `StdioBoardView.cpp`.
  * Отображение (или пара отображение+контроллер) принимает и хранит ссылку на модель.
  * Если реализовано несколько классов-отображений, то их общий
    интерфейс должен быть выделен в базовый класс `BoardView`,
    а общая логика взаимодействия с пользователем должна быть вынесена
    в отдельный контроллер.
* Если реализован контроллер, то он должен быть реализован в классе `GameController`
  в файлах `GameController.h` и `GameController.cpp` и работать с произвольным
  отображением, реализующим `BoardView`.
  Отображение хранится по ссылке.
* Точка входа реализована в `main.cpp`.
  В `main.cpp` запрещается реализовывать любую игровую логику
  или логику ввода-вывода, кроме как сборку классов вместе и
  запуск игры.
* Заглушки для некоторых классов предоставлены ниже.
  Используйте их как пример.
  Разрешается добавлять свои методы или даже менять имеющиеся,
  хотя и не рекомендуется.

```cpp
class Board {
public:                                  
    /** Проверить ход на корректность, если бы он был следующим. */
    bool canMove(int x, int y, XXX player);

    /** Сделать ход. UB, если он некорректен. */
    void move(int x, int y, XXX player);

    /** Состояние игры: игра идёт, игра кончилась с одним из результатов: ничья, победа одной из сторон. */
    YYY getState();
    
    // Можно добавлять методы при необходимости.
};
```
```cpp
class StdioBoardView {
public:
    StdioBoardView(Board &board);

    /** Основной цикл игры, от начала до конца. */
    void runGame();

    // Можно добавлять методы при необходимости.
};
```

### Фреймворк для тестов 
Поскольку автотестирование будет пригождаться и в будущем, требуется реализовать базовый функционал, на основе которого будут писаться юнит-тесты.
Реализуйте базовый класс `Test`, который будет являться родителем для конкретных наборов тестов:
```cpp
class Test {
protected:
    static int failedNum; // количество тестов, которые сломались
    static int totalNum;  // общее количество тестов
                                                                
    /** Проверяет условие (expr) на верность в конце теста.
        В одном тесте может быть не более одного `check`.
        Сообщает об результате пользователю, в случае неудачи подробно сообщает об источнике. */
    static void check(bool expr, const char *func, const char  *filename, size_t lineNum); 

public:
    /** Вызывается один раз в конце автотестов, выводит общую статистику по
        пройденным тестам на экран. Возвращает `true` если и только если
        все тесты успешно пройдены. */
    static bool showFinalResult();
    
    /** Запускает все тесты в конкретном наборе тестов */
    virtual void runAllTests() = 0;

    // Можно добавлять методы при необходимости 
};
```

Пользоваться функцией `check` довольно неудобно: программисту приходится каждый раз вручную указывать имя файла, имя функции и номер строки.
Для того, чтобы избавить программиста от этой рутины, необходимо реализовать макрос препроцессора `DO_CHECK`,
который использует команды препроцессора (`__func__` из С++11, `__FILE__`, `__LINE__`) и делает следующую подстановку:
```cpp
DO_CHECK(EXPR) → check(EXPR, __func__, __FILE__, __LINE__);
```

Пример автотеста для модели `Board`.
Тестовые методы приведены в качестве примера.
```cpp
class BoardTest : public Test {
private:
    void testIsWin() {
        Board b;
        b.move(0, 0, 1);
        b.move(0, 1, 1);
        b.move(1, 0, 1);
        b.move(4, 5, 0);
        b.move(5, 5, 0);
        DO_CHECK(b.isWin() == GAME_IN_PROGRESS);
    }
    
    void testMove1() {
        Board b;
        b.move(0, 0, 1);
        DO_CHECK(!b.canMove(0, 0, 0));
    }
    
    void testMove2() {
        Board b;
        m.move(0, 0, 1);
        DO_CHECK(b.canMove(1, 1, 1));
    }
    
    // ...
    
public:
    void runAllTests() override {
        testIsWin();
        testMove1();
        testMove2();
        // ...
    }

    // ...
};
```

Пример соответствующего `test.cpp`:
```cpp
int main() {
    BoardTest bt;
    bt.runAllTests();
    Test::showFinalResults();
    return 0;
}
```

### Структура тестов
* Все файлы с фреймворком и тестами должны находиться в подпапке `test`, а не `src`.
  При этом заголовочные файлы должны лежать в общем `include`.
* Базовый класс тестов `Test` должен быть реализован в `Test.h` и `Test.cpp`.
* Тесты модели `BoardTest` должны быть реализованы в `BoardTest.h` и `BoardTest.cpp`.
* Точка входа `main()` для тестов должна быть расположена в `test.cpp`.

### Структура репозитория
```
<корень-личного-репозитория>
|--hw-03_mv
   |--include
   |  |-- Board.h
   |  |-- BoardTest.h
   |  |-- ...
   |--src
   |  |-- Board.cpp
   |  |-- main.cpp
   |  |-- ...
   |--test
   |  |-- BoardTest.cpp
   |  |-- test.cpp
   |  |-- ...
   |--Makefile
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

## Бонусное задание
Реализуйте ещё одно отображение, класс `NcursesBoardView` в `NcursesBoardView.h` и `NcursesBoardView.cpp`.
Оно должно работать на основе библиотеки New Curses (`ncurses`, пакет в Ubuntu: `libncurses5-dev`).
По умолчанию программа использует класс `StdioBoardView`, но при запуске `./hw-03_mv curses` подключается `NcursesBoardView`.

В отличие от варианта на _stdio_, игровое поле все время перерисовывается на одном и том же месте.
Формат вывода игрового поле в целом такой же как и у StdioBoardView.
Ход осуществляется с помощью клавиш управления: влево, вправо, вверх, вниз и пробел (поставить крестик или нолик).
Клавиша `x` — досрочный выход из программы.
Управление должны быть устроено таким образом, чтобы нельзя было выйти за пределы доски или ввести некорректный ход.
При этом никаких сообщений об ошибке на экран не выводится.
Сообщение о результате партии должно быть такое же как и у `StdioBoardView`.

Здесь специально нет точных указаний, что сделать, вам даётся свобода.
Сделайте как вам покажется удобным, _но не заигрывайтесь_. 

## Сроки сдачи
Уточняйте у своего преподавателя.
